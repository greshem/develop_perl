#!/usr/bin/perl
foreach (<DATA>)
{
	print $_;
}
__DATA__

ARM 处理器有二十七个寄存器，其中一些是在一定条件下使用的，所以一次只能使用十六个...
ARM 2 和 3 有 27 个 32 位处理器寄存器，在任何给定时间只有其中的 16 个是可见的(是哪十六个取决于处理器模式)。它们被引用为 R0-R15。 
ARM 6 和以后有 31 个 32 位处理器寄存器，在任何给定时间只有其中的 16 个是可见的。 


寄存器 0 到寄存器 7 是通用寄存器并可以用做任何目的
		不象 80x86 处理器那样要求特定寄存器被用做栈访问，或者象 6502 那样把数学计算的结果放置到一个累加器中，ARM 处理器在寄存器使用上是高度灵活的。 
寄存器 8 到 12 是通用寄存器，但是在切换到 FIQ 模式的时候，使用它们的影子(shadow)寄存器。 
寄存器 13 典型的用做 OS 栈指针，但可被用做一个通用寄存器。这是一个操作系统问题，不是一个处理器问题，
		所以如果你不使用栈，只要你以后恢复它，你可以在你的代码中自由的占用(corrupt)它。每个处理器模式都有这个寄存器的影子寄存器。 
寄存器 14 专职持有返回点的地址以便于写子例程。
		当你执行带连接的分支的时候，把返回地址存储到 R14 中。同样在程序第一次运行的时候，把退出地址保存在 R14 中。
		R14 的所有实例必须被保存到其他寄存器中(不是实际上有效)或一个栈中。这个寄存器在各个处理器模式下都有影子寄存器。一旦已经保存了连接地址，
		这个寄存器就可以用做通用寄存器了。 
寄存器 15 是程序计数器。
		它除了持有指示程序当前使用的地址的二十六位数之外，还持有处理器的状态。 


        +------+---------------------------------------+
        | 模式 |  可获得的寄存器                        |
        +------+---------------------------------------+
        | USR  | R0             -             R14  R15 |
        +------+---------+-----------------------------+
        | FIQ  | R0 - R7 | R8_FIQ    -    R14_FIQ  R15 |
        +------+---------+----+------------------------+
        | IRQ  | R0   -   R12 | R13_IRQ - R14_IRQ  R15 |
        +------+--------------+------------------------+
        | SVC  | R0   -   R12 | R13_SVC - R14_SVC  R15 |
        +------+--------------+------------------------+
        | ABT  | R0   -   R12 | R13_ABT - R14_ABT  R15 | (ARM 6 和以后)
        +------+--------------+------------------------+
        | UND  | R0   -   R12 | R13_UND - R14_UND  R15 | (ARM 6 和以后)
        +------+---------------------------------------+

