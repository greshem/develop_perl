#!/usr/bin/perl
foreach (<DATA>)
{
	print $_;
}
__DATA__
   1.

      sed

      调用sed的语法有两种形式：

      sed [-n][-e] 'command' file(s)

      sed [-n] -f scriptfile file(s)

      -n 仅打印用p命令或s命令的p标记指定的行

                              如果脚本的第一行是“#n”，sed将按-n指定的方式工作

      -e cmd 下一个参数是编辑命令，当指定多个脚本时很有用

      -f file 下一个参数是一个包含编辑命令的文件

      有三种方式可以指定命令行上的多重指令：

      （1）用分号分割指令

                  $ sed 's/sam/sky/;s/bani/lucas/' file

（2）在每个指令前放置-e

$ sed -e 's/sam/sky/' -e 's/bani/lucas/' file

（3）使用Bourne shell的分行指令

$ sed '

> s/sam/sky/

>s/bani/lucas/' file

      注：输入文件不会有变化，只有将sed的输出重定向到另一个程序中，才能够捕获文件中的输出：

      sed -f scriptfile file > newfile

      sed首先将整个编辑脚本应用于第一个输入行，然后再读取第二个输入行并对其应用整个脚本。

      在替换命令的替换部分不必转移字面句点。

      sed使用大括号将一个地址嵌套在另一个地址中，或者在相同的地址上应用多个命令，如果想指定行的范围，然后在这个范围内指定另一个地址，则可以嵌套地址。左大括号必须在行末，而且右大括号本身必须单独占一行，要确保在大括号之后没有空格。

      sed脚本的4种类型：

      （1）对同一文件的多重编辑；

      （2）改变一组文件；

      （3）提取文件的内容；

      （4）编辑工作转移

      sed命令的普通形式为：

      [address[.address]][!]command[arguments]

      其中地址可以是一个行号或是由斜杠包含着的一个模式(/pattern/)，模式是用正则表达式描述的,另外\n可以用来与模式空间(N命令的结果)的任意换行符匹配，但模式空间底部的换行符除外。

      如果没有指定模式，相应的命令将被应用于所有的行，如果只指定了一个地址，那么相应的命令将被应用于和这个地址匹配的行，如果指定了两个用逗号分隔的地址，这个命令将被应用于位于第一个和第二个地址范围之间的所有行。

      在地址后面的！操作符使sed将相应的命令作用于所有与该地址不匹配的行。

      sed命令汇总：

      : label

      在脚本中标记一行，用于实现由b或t的控制转移，label最多可以包含7个字符。

      =[address]=

      将所寻址的行编写到标准输出

      a [address]a\

                  text

      在与address匹配的每行后面追加text，如果text多于一行，必须用反斜杠将这些行前面的换行符“隐藏”起来，text将被没有用这种方法隐藏的第一个换行符结束。text在模式空间中是不可用的并且后续的命令不能应用于它，当编辑命令的列表用完时这个命令的结果将被输送到标准输出，而不管在模式空间中的当前行发生了什么。

      b [address1[,address2]]b[label]

      无条件地将控制转移到脚本其他位置的：label处，也就是说，label后面的命令是应用于当前行的下一个命令，如果没有指定label，控制将一直到达脚本的末端，因此不在有命令作用于当前行。

      c [address[,address2]]c\

                  text

      用text替代（改变）由地址选定的行，当指定的是一个行范围时，将所有的这些行作为一个组由text的一个副本来替代。每个text行后面的换行符必须用反斜杠将其转义，但最后一行除外，实际上，模式空间的内容被删除，因此后续的命令不能应用于它。

      d [address1[,address2]]d

      从模式空间中删除行，因此行没有被传递到标准输出，一个新的输入行被读取，并用脚本的第一个命令来编辑。

      D [address1[,address2]]D

      删除由命令N创建的多行模式空间中的第一部分（直到嵌入的换行符），并且用脚本的第一条命令恢复编辑，如果这个命令使模式空间为空，那么将读取一个新的输入行，和执行了d命令一样。

      g [address1[,address2]]g

      将保持空间中的内容复制到模式空间中，并将当前的内容清除。

      G [address1[,address2]]G

      将换行符后的保持空间内容追加到模式空间中，如果保持空间为空，则将换行符添加到模式空间。

      h [address1[,address2]]h

      将模式空间的内容复制到保存空间，即一个特殊的临时缓冲区，保存空间的当前内容被清除。

      H [address1[,address2]]H

      将换行符和模式空间的内容追加到保持空间中，即使保持空间为空，这个命令也追加换行符。

      i [address1]i\

                  text

      将text插入到每个和address匹配的行的前面。

      l [address1[,address2]]l

      列出模式空间的内容，将不可打印的字符表示为ASCII码，长的行被折行。

      n [address1[,address2]]n

      读取下一个输入行到模式空间，当前行被送到标准输出，新行成为当前行并递增计数器，将控制转到n后面的命令，而不是恢复到脚本的顶部。

      N [address1[,address2]]N

      将下一个输入行追加到模式空间的内容之后，新添加的行与模式空间的当前内容用换行符分隔（这个命令用于实现跨两行的模式匹配，利用\n来匹配嵌入的换行符，则可以实现多行模式匹配）。

      p [address1[,address2]]p

      打印所寻址的行，注意这将导致输出的重复，除非默认的输出用#n或-n命令行选项限制，常用于改变流控制(d,n,b)的命令之前并可能阻止当前行被输出。

      P [address1[,address2]]P

      打印由N命令创建的多行模式空间的第一部分（直到嵌入的换行符）。如果没有将N应用于某一行则和p相同。

      q [address]q

      当遇到address时退出，寻址的行首先被写到输出（如果没有限制默认输出），包括用前面的a或r命令为它追加的文本。

      r [address]r file

      读取file的内容并追加到模式空间内容的后面，必须在r和文件名file之间保留一个空格。

      s [address1[,address2]]s/pattern/replacement/[flags]

      用replacement代替每个寻址行的pattern，如果使用了模式地址，那么模式//表示最后指定的模式地址，可以指定下面的标志：

            n 替代每个寻址的行的第n个/pattern/。N是1到512之间的任意 数字，并且默认为1。

            g 替代每个寻址的行的所有/pattern/，而不只是第一个。

            p 如果替换成功则打印这一行，如果成功进行了多个替换，将打印 这个行的多个副本。

            w file 如果发生一次替换则将这行写入file，最多可以打开10个不同的 file.

      T [address1[,address2]]t[label]

      测试在寻址的行范围内是否成功执行了替换，如果是，则转移到有label标志的行，如果没有给出label，控制将转移到脚本的底部。

      w [address1[,address2]]w file

      将模式空间的内容追加到file，这个动作是在遇到命令时发生而不是在输出模式空间内容时发生。必须在w和这个文件名之间保留一个空格，在脚本中可以打开的最大文件数是10，如果文件不存在，这个命令将创建一个文件，如果文件存在，则每次执行脚本时将改写其内容，多重写入命令直接将输出写入到同一个文件并追加到这个文件的末端。

      x [address1[,address2]]x

      交换模式空间和保持空间的内容。

      y [address1[,address2]]y/abc/xyz/

      按位置将字符串abc中的字符转成字符串xyz中的相应字符。
#############################
